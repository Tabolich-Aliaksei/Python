"""
Задание 1.
Реализуйте функции:
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
ВНИМАНИЕ: в задании три пункта
НУЖНО выполнить каждый пункт
обязательно отделяя каждый пункт друг от друга
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
вы уже знаете, что такое декоратор и как его реализовать,
обязательно реализуйте ф-цию-декоратор и пусть она считает время
И примените ее к своим функциям!
"""

import time

my_list = []
my_dict = {}


def p_wrapper(func):
    def function(*args, **kwargs):
        for i in range(5):
            start = time.time()
            for i in range(100000):
                func(*args, **kwargs)
            end = time.time()
            print(f'Время выполнения: {end - start}')
    return function


"""
a) заполнение списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   заполнение словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
"""

print(' Замер времени заполнение списка:')

# O(n) - линейная


@p_wrapper
def func_app(*args):
    for i in args:                    #O(n)
        my_list.append(i)             #O(1)


func_app(1, 2, 3, 4, 5)

# O(n) - линейная

print('\n   Замер времени заполнение словаря:')


@p_wrapper
def func_up(**kwargs):
    for key, val in kwargs.items():     #O(n)
        my_dict[key] = val              #O(1)


func_up(a='1', b='2', c='3')

"""
b) получение элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   получение элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
"""

# O(n) - линейная

print(f'\n  Замер времени получение элемента списка: ')


@p_wrapper
def elem_list(lst):
    for i in lst:                   #O(n)
        return i                    #O(1)


elem_list(my_list)

# O(n) - линейная

print(f'\n  Замер времени получение элемента словаря: ')


@p_wrapper
def elem_dict(dct):
    for key, val in dct.items():    #O(n)
        return key, val             #O(1)


elem_dict(my_dict)


"""
с) удаление элемента списка, оцените сложность в O-нотации (операции нужно провдить в цикле)
   удаление элемента словаря, оцените сложность в O-нотации (операции нужно провдить в цикле)
   сделайте аналитику, что заполняется быстрее и почему
   сделайте замеры времени
"""

# O(1) - константная

print(f'\n  Замер времени удаление элемента списка: ')


@p_wrapper
def pop_list(lst):
    while len(lst) > 0:         #O(1)
        lst.pop()               #O(1)


pop_list(my_list)

# O(1) - константная

print(f'\n  Замер времени удаление элемента словаря: ')


@p_wrapper
def pop_dict(dct):
    while len(dct) > 0:         #O(1)
        dct.popitem()           #O(1)


pop_dict(my_dict)
